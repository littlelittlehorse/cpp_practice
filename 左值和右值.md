# 左值和右值

## 定义

当一个对象被用作右值的时候，用的是对象的值(内容)。
当一个对象被用作左值的时候，用的是对象的身份(在内存中的地址)。



## 对象的移动

对象的移动，是相对于对象的拷贝提出的，很多对象被拷贝后就立即被销毁了。
因此，在这种情况下，移动而非拷贝对象会大幅度提升性能。



**移动而非拷贝的场景**

- 被拷贝对象，在拷贝后就销毁。
- IO类和 `unique_ptr`类，这些类都包含不能共享的资源(IO缓冲或指针)，因此这类对象不能拷贝但可以移动。



## 右值引用

为了支持移动操作，而提出新的引用类型。

### 重要性质

- 只能绑定到一个即将销毁的对象。不能绑定到一个左值上。

### 常规引用(左值引用)

- 引用只是别名。
- 不能绑定要求转化的表达式、字面常量、返回右值的表达式。
- 常规引用，程序把引用和它的初始值绑定在一起，而不是将初始值拷贝给引用。**一旦初始化完成，引用和它的初始值对象一直绑定在一起，因此无法令引用重新绑定到另外一个对象，因此引用必须初始化。**





## 标准库`move`函数

`move`的出现，是为了解决右值引用不能直接绑定到一个左值上。如下:

```c++
int i = 42;
int &&r = i; // 错误，不能将一个右值引用绑定到一个左值上。
```



`move`函数实现了：

- 显式的将一个左值转换为对应的右值引用类型。
- 在上面的基础上，并获得绑定到左值上的右值引用。

```c++
int &&r = move(i);
```





## 13.6.1节习题

**1、左值引用和右值引用区别**

- 左值引用：目的是别名。

- 右值引用：目的是减少拷贝，支持移动操作。



**2、move函数的用途**

move函数提出的目的是，对于右值引用，只能绑定到即将销毁的对象上，无法直接绑定到一个左值上。

`move`的提出，支持显式的获取一个左值上右值引用。

移动后的源对象，可以销毁或赋值，但不能使用它，不能对移动后的源对象的值做任何假设。

